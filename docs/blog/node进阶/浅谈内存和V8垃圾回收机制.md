# 浅谈内存和`V8`引擎垃圾回收机制

1. node运行内存的大小受到`v8`引擎的限制，那么如何扩大这个内存呢，需要在启动的时候，加入设置

   ```javascript
   node   --max-old-space-size=1700  xxx.js    // 单位为MB   设置老生代堆内存的大小
   
   node   --max-new-space-size=1700   xxx.js  // 单位为KB     设置新生代堆内存的大小
   
   //需要在启动的时候就设置，并且没有办法进行自动扩充
   ```

2. **node 垃圾回收机制，内存分为新生代和老生代两部分，新生代是那些时间比较短的，老生代是需要长时间存在的。**

3. 新生代内存中的垃圾回收机制 `Scavenge`

   - **新生代的回收机制，分为两部分空间，一个是from, 一个是to,  回收的时候，将from中带活跃标记的复制到to这个空间去，然后把from清空，最后将to和from的身份进行交换，to变成from, from变成to。**
   - **如果新生代from中的对象从，from复制到to的过程中，这个对象已经经历过回收一次或者以上了，那么这个对象，会被直接放到老生代内存中， 接受老生带内存的回收机制。**
   - **如果在回收过程中，to空间的使用大小  大于等于25%的时候，后面从from复制出来活跃对象，会被放置到老生代的里面去，接受老生代的回收机制，原因是因为，后面to空间会变成from空间，会接收新的一些对象进来，需要预留足够的内存。**

4.  老生代内存中的垃圾回收机制
   - 老生代内存中，采用**标记清除（Mark-Sweep）**机制，来清除那些已经不活跃的对象，在标记阶段，会标记中所有活着的对象，清除的时候，会清除掉所有没有被标记中的对象。
   - 有一个问题，在清除的过程中，堆内存中会产生许多，内存碎片，比较零零散散的，如果需要存储大对象的时候，这个时候，就存不下来，所以，老生代这里引入了内存碎片整理的机制，叫**标记整理（`Mark-Compat`）**机制，将标记为死亡的内存，都统一规整的内存一边，这样的话，存活的内存和死亡的内存，就泾渭分明，然后直接一次性把死亡对象占有的内存直接释放掉，这样就不会产生内存碎片的问题了。
   - 但是标记整理机制，清理起来过慢，只有从新生代进入到老生代的内存中的对象，才会执行这种标记整理的机制，原老生带的内存或者不是从新生代过来的内存，是使用标记清除的方式的。
5. 回收机制总结
   - 在`V8`引擎的垃圾回收机制中，这三种机制是同时使用的
   - 新生代使用 `Scavenge`,   from 和 to 两个内存的方式。
   - 新生代进入到老生代的对象，使用的是标记整理的方式`Mark-Compat`
   - 直接进入老生代，或者原老生代的内存，是使用标记清除方式的`Mark-Sweep`
6. 垃圾处理时间和`JS`逻辑处理时间的冲突
   - 垃圾回收处理的时候，是属于全停顿时间，也就是这个时候，`JS`的逻辑处理是停止的，不进行处理。
   - 在新生代的回收机制中，这个是不太影响的，因为新生代的内存较小，虽然回收频繁，但是时间非常短，基本感觉不到，所以不太影响这个`JS`的逻辑处理。
   - 但是对于老生代的内存垃圾来说，就不太行了，老生代内存中垃圾比较多，回收记起来比较慢，所以需要改进这个回收的时间机制，采用了交替进行的方式，就是执行一段时间`JS`逻辑处理，执行一会儿老生带的内存回收，交替进行，把不本来需要一次性执行完的回收机制，分段处理了，这种方式叫做延迟清理
   - 还有就是标记的过程，也是交替进行，叫做增量标记
   - 标记整理的机制，也是交替进行，叫做增量式整理





##### 如何在node中高效的使用内存？

1. 不用的变量及时赋值为`undefined `或者 `null `

#### 堆外内存

1. 对于`Buffer `也就是说进制数据，其实是不存在于`V8`引擎分配的内存中的，所以存在的地方称作堆外内存。
2. 但是为什么会产生这个堆外内存呢？  因为`node`跟浏览器的应用场景是不一样的，在浏览器当中，`JS `直接处理字符串是可以满足绝大部分的需求的，但是在node当中需要去处理**网络流和文件I/O流**， 如果直接是操作字符串，性能会有很大的问题，性能低下，并且，如果文件过大，对于内存来说，是不够的。但是操作二进制流的话，速度会非常快，并且，二进制流可以不去占用`V8`引擎分配的内存，存储于堆内存之外，所以称之为堆外内存。

#### 内存泄漏

`node`中常见的三种内存泄漏的方式：

- 缓存
- 队列消除不及时
- 作用域未释放





#### 堆外内存分配（Buffer内存分配）

- 为了避免操作一点内存，就像操作系统申请一次内存的问题。所以将内存的申请放在的`C++`层面，将内存的分配放在了`JS`中。
- 分为大对象和小对象，小于`8k`, 就是小对象
- 对于小对象，`Node`采用了`slab`的动态内存管理机制，一个`slab`为一个最小的单元，如果不够就增加`slab`, 如果当前`slab`有存数据，再次存入的数据大于当前`slab`剩余的内存，就会重新开一个`slab`, 原先上一个`slab`中的内容就会自己独占一个`slab`。
- `slab`有三种状态： `full`完全分配状态，`partial`部分分配状态，`empty`没有被分配状态

