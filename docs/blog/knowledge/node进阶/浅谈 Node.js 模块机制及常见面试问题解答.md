# 浅谈 `Node.js` 模块机制

###   模块加载机制， require()时的，在 `Node.js` 中模块加载一般会经历 3 个步骤，`路径分析`、`文件定位`、`编译执行`。

1. **系统缓存**：模块被执行之后，会进行缓存，**缓存是编译和执行之后的对象，核心模块的缓存检查会优先于文件模块的缓存**；首先先去访问缓存里面有没有这个文件，如果有的话，直接加载缓存文件，如果没有的话，就继续访问 2 中有没有。
2. **系统模块**：系统缓存没有的前提下，会访问系统模块，例如`fs`,  `path`等内置的模块，省略了 `路径分析`、`文件定位`
3. **文件模块**：如果没有在系统内置的模块中找到，那就会去找目录中的文件， 进行省略了 `路径分析`、`文件定位`， 找到文件之后，然后`编译执行`， **如果文件没有加上扩展名，会依次按照 `.js`、`.json`、`.node` 进行扩展名补足尝试**
4. **目录做为模块**：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个 `包` 来处理，Node 这块采用了 `Commonjs `规范，先会在项目根目录查找 `package.json` 文件，取出文件中定义的 main 属性 `("main": "lib/hello.js")` 描述的入口文件进行加载，也没加载到，则会抛出默认错误: `Error: Cannot find module 'lib/hello.js'`
5. **node_modules 目录加载**：对于系统模块、路径文件模块都找不到，`Node.js `会从当前模块的父目录进行查找，直到系统的根目录

​    

- **注意：** 我们可以通过`require.cache `    `Api`的方式查询当前，内粗那种缓存的文件

- 有一个`a.js` 其中有一个变量没有被定义，直接赋值了，例如`name = "123"`, 并没有`var`,  `let`, `const` 等定义，那么这个属于整个`node`的全局变量， 所以`name`是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方当然是可以拿到的。 

- `exports`和`module.exports`的区别：`exports `相当于` module.exports` 的快捷方式如下所示:

  ```javascript
  const exports = module.exports;
  
  //exports 是一个对象， 它的this 指向了 module.exports  
  
  所以 我们不能直接将对象赋值给exports 这样就改变了它的this指向。 就没法用了
  
  //错误导出
  exports = {
       name: "123"
  }
  
  //正确导出
  exports.name = "123";
  ```

  

