(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{356:function(v,_,e){"use strict";e.r(_);var t=e(33),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"es6-部分功能介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-部分功能介绍"}},[v._v("#")]),v._v(" ES6 部分功能介绍")]),v._v(" "),e("h4",{attrs:{id:"let-和-const-的使用规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const-的使用规范"}},[v._v("#")]),v._v(" "),e("code",[v._v("let")]),v._v(" 和 "),e("code",[v._v("const")]),v._v(" 的使用规范")]),v._v(" "),e("ol",[e("li",[e("p",[e("strong",[v._v("let")]),v._v("\n-  与"),e("code",[v._v("var")]),v._v("不同，"),e("code",[v._v("let")]),v._v("和"),e("code",[v._v("const")]),v._v("都是模块化的，必须先声明定义后，才能使用。\n- "),e("code",[v._v("let")]),v._v("声明的变量不允许重复，在同一个作用域内部。\n- 外部作用域，不能访问内部作用域的"),e("code",[v._v("let")]),v._v("；\n- for 循环括号中声明的变量只能在循环体中使用。\n- 块级作用域内部，变量只能先声明后使用")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("const")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("const")]),v._v("用来声明常量。")]),v._v(" "),e("li",[e("code",[v._v("const")]),v._v("声明的常量不允许重新复制")]),v._v(" "),e("li",[e("code",[v._v("const")]),v._v("声明的常量必须初始化，就是说必需给赋值。")])])])]),v._v(" "),e("h4",{attrs:{id:"变量的结构赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量的结构赋值"}},[v._v("#")]),v._v(" 变量的结构赋值")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("数组的解构赋值")]),v._v(" "),e("p",[e("code",[v._v("let [ a, b, c ] = [ 1, 2, 3 ]")]),v._v(" 相当于  "),e("code",[v._v("let a = 1; let b = 2; let c = 3")])]),v._v(" "),e("ul",[e("li",[v._v("注意：左边的数组中，顺序不同，解构后对应的数据也会发生改变。")])])]),v._v(" "),e("li",[e("p",[v._v("对象的解构赋值")]),v._v(" "),e("p",[e("code",[v._v("let { a, b, c } = { a: 1, b: 2, c: 3}")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("注意： 这样解构的的属性，必须是存在于被解构的对象中的")])]),v._v(" "),e("li",[e("p",[v._v("当然也是可以重新命名的 "),e("code",[v._v("let { a, b:d, c} = { a: 1, b: 2, c: 3}")]),v._v("    此时用的话就没有"),e("code",[v._v("b")]),v._v("这个变量 只有"),e("code",[v._v("d")]),v._v("这个变量，就是起了一个别名。")])]),v._v(" "),e("li",[e("p",[v._v("左边的对象中，顺序是没有什么影响的，可以打乱。")])]),v._v(" "),e("li",[e("p",[v._v("只要是一个对象"),e("code",[v._v("{}")]),v._v("都是可以被解构的， 像"),e("code",[v._v("JS")]),v._v("的内置对象 "),e("code",[v._v("Math")]),v._v(",  "),e("code",[v._v("Date")]),v._v("都是可以进行解构赋值。")])])])]),v._v(" "),e("li",[e("p",[v._v("字符串的解构赋值")]),v._v(" "),e("p",[e("code",[v._v('let [a, b ,c ,d ,e] = "hello"')]),v._v(" 相当于 "),e("code",[v._v('let a= "h":let b = "e"; let c ="l";...')]),v._v("依次对应")]),v._v(" "),e("ul",[e("li",[v._v("可以利用对象赋值的方式用于字符串的 "),e("code",[v._v('let { length } = "hello"')]),v._v("; 可以直接拿到字符串的长度。")])])])]),v._v(" "),e("h4",{attrs:{id:"字符串的扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串的扩展"}},[v._v("#")]),v._v(" 字符串的扩展")]),v._v(" "),e("ol",[e("li",[e("p",[e("code",[v._v("includes()")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("用于寻找字符串中，有没有包含某个字符串 "),e("code",[v._v("includes('xxx')")]),v._v("；")])]),v._v(" "),e("li",[e("p",[v._v("参数1： 要匹配的字符串， 参数2：从第几个开始匹配。")])])])]),v._v(" "),e("li",[e("p",[e("code",[v._v("startsWith()")])])])]),v._v(" "),e("ul",[e("li",[v._v("判断字符串是不是以特定的字符串开始。")])]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[e("code",[v._v("endWith()")])]),v._v(" "),e("ul",[e("li",[v._v("判断字符串是不是以特定的字符串结尾。")])])]),v._v(" "),e("li",[e("p",[v._v("模板字符串")]),v._v(" "),e("ul",[e("li",[v._v('就是以   " ``" 两个撇包含在呢的字符串，或者html等 json')]),v._v(" "),e("li",[v._v("变量在其中以"),e("code",[v._v("${xxx}")]),v._v("的方式进行引入就可以了。")])])])]),v._v(" "),e("h4",{attrs:{id:"函数的相关扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数的相关扩展"}},[v._v("#")]),v._v(" 函数的相关扩展")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("参数默认值")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("其实就是给函数的形参，直接等于一个值，这个的意思就是，当没传递值的时候，这个形参就是这个默认值，如果传参了，就是传参的值。")]),v._v(" "),e("p",[e("code",[v._v("function(params = 123){};")])])])])]),v._v(" "),e("li",[e("p",[v._v("参数的解构赋值")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("这个就是例如如果传入的参数是一个对象，那么在函数的形参里，可以将传入进来的对象进行解构。")]),v._v(" "),e("p",[e("code",[v._v("function ({ name, id }){};")])])])])]),v._v(" "),e("li",[e("p",[v._v("其余参数， rest参数")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("比如传递给函数的参数很多，我们就可以利用rest参数，接收除了前面设置好的参数外的其余参数")]),v._v(" "),e("p",[e("code",[v._v("funtion (a1, a2, ...rest){};")]),v._v(" "),e("code",[v._v("rest")]),v._v("拿到的就是除了"),e("code",[v._v("a1, a2")]),v._v("之外所有的参数了。")])])])]),v._v(" "),e("li",[e("p",[v._v("...扩展运算符")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("就是传给给函数的参数，例如数组，可以"),e("code",[v._v("...arr")]),v._v("的方式，将数组的内容，打散开传入给函数。")]),v._v(" "),e("p",[e("code",[v._v("var arr = [ 1, 2, 3, 4, 5 ];")])]),v._v(" "),e("p",[e("code",[v._v("function (...arr){}")])])]),v._v(" "),e("li",[e("p",[v._v("可以合并数组 "),e("code",[v._v("let arr3 = [...arr1, ...arr2 ]")])])])])]),v._v(" "),e("li",[e("p",[v._v("箭头函数")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("let foo = (v) => v")])])]),v._v(" "),e("li",[e("p",[v._v("当内部是直接"),e("code",[v._v("return")]),v._v("的时候，"),e("code",[v._v("return")]),v._v("是可以省略的")])]),v._v(" "),e("li",[e("p",[v._v("箭头函数内部的"),e("code",[v._v("this")]),v._v("指向父级，如果父级还是箭头函数，则继续往上，知道找到对应的"),e("code",[v._v("this")])])]),v._v(" "),e("li",[e("p",[v._v("注意：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("箭头函数中的"),e("code",[v._v("this")]),v._v("取决于函数的定义， 而不是调用。")])]),v._v(" "),e("li",[e("p",[v._v("箭头函数不能使用"),e("code",[v._v("new")]),v._v("方法。")])]),v._v(" "),e("li",[e("p",[v._v("箭头函数不能是用"),e("code",[v._v("arrguments")]),v._v("来获取参数列表,   可以使用"),e("code",[v._v("rest")]),v._v("参数代替")]),v._v(" "),e("p",[e("code",[v._v("let foo = (...params) { console.log(params)}")])])])])])])])]),v._v(" "),e("h4",{attrs:{id:"类和继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类和继承"}},[v._v("#")]),v._v(" 类和继承")]),v._v(" "),e("ol",[e("li",[e("p",[e("code",[v._v("es6")]),v._v("的类实现方法就是语法糖class")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("class Animal {\n   //静态方法 只能通过类名调用 \n       static  showInfo () {}`  \n        constructor(name){\n            this.name = name`\n         }\n}\n")])])])]),v._v(" "),e("li",[e("p",[v._v("类的继承 关键字 "),e("code",[v._v("extends")])]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("2. class Dog extends Animal {\n          constructor(name){\n            super(name)\n        }\n   }\n")])])])]),v._v(" "),e("li",[e("p",[v._v("最后 "),e("code",[v._v('let dog = new Dog("123")')])])]),v._v(" "),e("li",[e("p",[v._v("静态方法的继承，就直接继承过来了，"),e("code",[v._v("Dog")]),v._v("可以直接使用"),e("code",[v._v("showInfo")]),v._v(" "),e("code",[v._v("Dog.showInfo()")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);