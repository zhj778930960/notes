(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{591:function(v,_,e){"use strict";e.r(_);var s=e(4),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("ol",[e("li",[e("p",[v._v("node运行内存的大小受到"),e("code",[v._v("v8")]),v._v("引擎的限制，那么如何扩大这个内存呢，需要在启动的时候，加入设置")]),v._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[v._v("node   "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("--")]),v._v("max"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("old"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("space"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("size"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("1700")]),v._v("  xxx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("js    "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 单位为MB   设置老生代堆内存的大小")]),v._v("\n\nnode   "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("--")]),v._v("max"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("space"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("size"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("1700")]),v._v("   xxx"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("js  "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 单位为KB     设置新生代堆内存的大小")]),v._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//需要在启动的时候就设置，并且没有办法进行自动扩充")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br"),e("span",{staticClass:"line-number"},[v._v("5")]),e("br")])])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("node 垃圾回收机制，内存分为新生代和老生代两部分，新生代是那些时间比较短的，老生代是需要长时间存在的。")])])]),v._v(" "),e("li",[e("p",[v._v("新生代内存中的垃圾回收机制 "),e("code",[v._v("Scavenge")])]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("新生代的回收机制，分为两部分空间，一个是from, 一个是to,  回收的时候，将from中带活跃标记的复制到to这个空间去，然后把from清空，最后将to和from的身份进行交换，to变成from, from变成to。")])]),v._v(" "),e("li",[e("strong",[v._v("如果新生代from中的对象从，from复制到to的过程中，这个对象已经经历过回收一次或者以上了，那么这个对象，会被直接放到老生代内存中， 接受老生带内存的回收机制。")])]),v._v(" "),e("li",[e("strong",[v._v("如果在回收过程中，to空间的使用大小  大于等于25%的时候，后面从from复制出来活跃对象，会被放置到老生代的里面去，接受老生代的回收机制，原因是因为，后面to空间会变成from空间，会接收新的一些对象进来，需要预留足够的内存。")])])])]),v._v(" "),e("li",[e("p",[v._v("老生代内存中的垃圾回收机制")])])]),v._v(" "),e("ul",[e("li",[v._v("老生代内存中，采用**标记清除（Mark-Sweep）**机制，来清除那些已经不活跃的对象，在标记阶段，会标记中所有活着的对象，清除的时候，会清除掉所有没有被标记中的对象。")]),v._v(" "),e("li",[v._v("有一个问题，在清除的过程中，堆内存中会产生许多，内存碎片，比较零零散散的，如果需要存储大对象的时候，这个时候，就存不下来，所以，老生代这里引入了内存碎片整理的机制，叫**标记整理（"),e("code",[v._v("Mark-Compat")]),v._v("）**机制，将标记为死亡的内存，都统一规整的内存一边，这样的话，存活的内存和死亡的内存，就泾渭分明，然后直接一次性把死亡对象占有的内存直接释放掉，这样就不会产生内存碎片的问题了。")]),v._v(" "),e("li",[v._v("但是标记整理机制，清理起来过慢，只有从新生代进入到老生代的内存中的对象，才会执行这种标记整理的机制，原老生带的内存或者不是从新生代过来的内存，是使用标记清除的方式的。")])]),v._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[v._v("回收机制总结\n"),e("ul",[e("li",[v._v("在"),e("code",[v._v("V8")]),v._v("引擎的垃圾回收机制中，这三种机制是同时使用的")]),v._v(" "),e("li",[v._v("新生代使用 "),e("code",[v._v("Scavenge")]),v._v(",   from 和 to 两个内存的方式。")]),v._v(" "),e("li",[v._v("新生代进入到老生代的对象，使用的是标记整理的方式"),e("code",[v._v("Mark-Compat")])]),v._v(" "),e("li",[v._v("直接进入老生代，或者原老生代的内存，是使用标记清除方式的"),e("code",[v._v("Mark-Sweep")])])])]),v._v(" "),e("li",[v._v("垃圾处理时间和"),e("code",[v._v("JS")]),v._v("逻辑处理时间的冲突\n"),e("ul",[e("li",[v._v("垃圾回收处理的时候，是属于全停顿时间，也就是这个时候，"),e("code",[v._v("JS")]),v._v("的逻辑处理是停止的，不进行处理。")]),v._v(" "),e("li",[v._v("在新生代的回收机制中，这个是不太影响的，因为新生代的内存较小，虽然回收频繁，但是时间非常短，基本感觉不到，所以不太影响这个"),e("code",[v._v("JS")]),v._v("的逻辑处理。")]),v._v(" "),e("li",[v._v("但是对于老生代的内存垃圾来说，就不太行了，老生代内存中垃圾比较多，回收记起来比较慢，所以需要改进这个回收的时间机制，采用了交替进行的方式，就是执行一段时间"),e("code",[v._v("JS")]),v._v("逻辑处理，执行一会儿老生带的内存回收，交替进行，把不本来需要一次性执行完的回收机制，分段处理了，这种方式叫做延迟清理")]),v._v(" "),e("li",[v._v("还有就是标记的过程，也是交替进行，叫做增量标记")]),v._v(" "),e("li",[v._v("标记整理的机制，也是交替进行，叫做增量式整理")])])])]),v._v(" "),e("h5",{attrs:{id:"如何在node中高效的使用内存？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何在node中高效的使用内存？"}},[v._v("#")]),v._v(" 如何在node中高效的使用内存？")]),v._v(" "),e("ol",[e("li",[v._v("不用的变量及时赋值为"),e("code",[v._v("undefined")]),v._v("或者 "),e("code",[v._v("null")])])]),v._v(" "),e("h4",{attrs:{id:"堆外内存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆外内存"}},[v._v("#")]),v._v(" 堆外内存")]),v._v(" "),e("ol",[e("li",[v._v("对于"),e("code",[v._v("Buffer")]),v._v("也就是说进制数据，其实是不存在于"),e("code",[v._v("V8")]),v._v("引擎分配的内存中的，所以存在的地方称作堆外内存。")]),v._v(" "),e("li",[v._v("但是为什么会产生这个堆外内存呢？  因为"),e("code",[v._v("node")]),v._v("跟浏览器的应用场景是不一样的，在浏览器当中，"),e("code",[v._v("JS")]),v._v("直接处理字符串是可以满足绝大部分的需求的，但是在node当中需要去处理"),e("strong",[v._v("网络流和文件I/O流")]),v._v("， 如果直接是操作字符串，性能会有很大的问题，性能低下，并且，如果文件过大，对于内存来说，是不够的。但是操作二进制流的话，速度会非常快，并且，二进制流可以不去占用"),e("code",[v._v("V8")]),v._v("引擎分配的内存，存储于堆内存之外，所以称之为堆外内存。")])]),v._v(" "),e("h4",{attrs:{id:"内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[v._v("#")]),v._v(" 内存泄漏")]),v._v(" "),e("p",[e("code",[v._v("node")]),v._v("中常见的三种内存泄漏的方式：")]),v._v(" "),e("ul",[e("li",[v._v("缓存")]),v._v(" "),e("li",[v._v("队列消除不及时")]),v._v(" "),e("li",[v._v("作用域未释放")])]),v._v(" "),e("h4",{attrs:{id:"堆外内存分配（buffer内存分配）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆外内存分配（buffer内存分配）"}},[v._v("#")]),v._v(" 堆外内存分配（Buffer内存分配）")]),v._v(" "),e("ul",[e("li",[v._v("为了避免操作一点内存，就像操作系统申请一次内存的问题。所以将内存的申请放在的"),e("code",[v._v("C++")]),v._v("层面，将内存的分配放在了"),e("code",[v._v("JS")]),v._v("中。")]),v._v(" "),e("li",[v._v("分为大对象和小对象，小于"),e("code",[v._v("8k")]),v._v(", 就是小对象")]),v._v(" "),e("li",[v._v("对于小对象，"),e("code",[v._v("Node")]),v._v("采用了"),e("code",[v._v("slab")]),v._v("的动态内存管理机制，一个"),e("code",[v._v("slab")]),v._v("为一个最小的单元，如果不够就增加"),e("code",[v._v("slab")]),v._v(", 如果当前"),e("code",[v._v("slab")]),v._v("有存数据，再次存入的数据大于当前"),e("code",[v._v("slab")]),v._v("剩余的内存，就会重新开一个"),e("code",[v._v("slab")]),v._v(", 原先上一个"),e("code",[v._v("slab")]),v._v("中的内容就会自己独占一个"),e("code",[v._v("slab")]),v._v("。")]),v._v(" "),e("li",[e("code",[v._v("slab")]),v._v("有三种状态： "),e("code",[v._v("full")]),v._v("完全分配状态，"),e("code",[v._v("partial")]),v._v("部分分配状态，"),e("code",[v._v("empty")]),v._v("没有被分配状态")])])])}),[],!1,null,null,null);_.default=a.exports}}]);